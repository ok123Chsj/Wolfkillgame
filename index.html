<!DOCTYPE html>
<html lang="zh-HK">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <title>ç«æŸ´äººï¼šè¬è±¡æ³•å‰‡ (v11.5 å›ºå®šç‰ˆ)</title>
    <style>
        body { margin: 0; overflow: hidden; background-color: #1a1a1a; color: white; font-family: 'Segoe UI', sans-serif; touch-action: none; user-select: none; -webkit-user-select: none; }
        #game-container { position: relative; width: 100vw; height: 100vh; overflow: hidden; } /* Overflow hidden for shake */
        canvas { display: block; width: 100%; height: 100%; }

        /* UI Layers */
        .ui-layer { position: absolute; top: 0; left: 0; width: 100%; height: 100%; pointer-events: none; display: flex; flex-direction: column; }

        /* Selection Screen */
        #char-select-screen { background: rgba(0, 0, 0, 0.95); z-index: 100; pointer-events: auto; display: flex; flex-direction: row; width: 100%; height: 100%; }
        .select-left { width: 50%; display: flex; flex-direction: column; align-items: center; height: 100%; overflow-y: auto; padding-top: 20px; border-right: 1px solid #444; }
        .select-right { width: 50%; height: 100%; padding: 20px; display: flex; flex-direction: column; justify-content: center; background: #222; box-sizing: border-box; }

        .char-grid { display: grid; grid-template-columns: repeat(3, 1fr); gap: 15px; margin-bottom: 20px; padding: 10px; }
        .char-card { width: 80px; height: 100px; border: 2px solid #555; border-radius: 8px; background: #333; display: flex; flex-direction: column; align-items: center; justify-content: center; cursor: pointer; transition: transform 0.1s; position: relative; }
        .char-card.selected { border-color: #ffd700; box-shadow: 0 0 15px #ffd700; transform: scale(1.05); }
        .new-tag { font-size: 8px; background: #ff00ff; padding: 2px; border-radius: 2px; position:absolute; top:-5px; right:-5px; }
        .char-icon { font-size: 30px; margin-bottom: 5px; }
        .char-name { font-size: 10px; text-align: center; color: #ddd; }

        /* Info Panel */
        #info-panel { text-align: left; display: none; height: 100%; overflow-y: auto; padding-right: 5px; }
        #info-name { font-size: 24px; font-weight: bold; color: #ffd700; margin-bottom: 5px; }
        #info-role { font-size: 12px; color: #aaa; margin-bottom: 10px; font-weight: bold; letter-spacing: 1px; }
        #info-desc { font-style: normal; color: #ddd; margin-bottom: 15px; font-size: 13px; line-height: 1.5; border-left: 3px solid #ffd700; padding-left: 10px; background: rgba(255,255,255,0.05); padding: 10px; border-radius: 0 5px 5px 0; }
        
        .skill-section-title { font-size: 16px; color: #fff; border-bottom: 1px solid #555; margin-bottom: 10px; padding-bottom: 5px; margin-top: 10px;}
        .skill-info { margin-bottom: 10px; background: rgba(0,0,0,0.3); padding: 10px; border-radius: 8px; border: 1px solid #444; }
        .skill-name { color: #00aaff; font-weight: bold; font-size: 15px; margin-bottom: 3px; display: flex; justify-content: space-between;}
        .skill-detail { color: #ccc; font-size: 12px; line-height: 1.4; }
        
        .btn-group { margin-top: 15px; display: flex; gap: 10px; flex-wrap: wrap; padding-bottom: 20px; }
        .confirm-btn { flex: 1; background: linear-gradient(135deg, #ff9900 0%, #ff5500 100%); border: none; color: white; padding: 12px; border-radius: 8px; font-size: 18px; font-weight: bold; cursor: pointer; }
        .confirm-btn:disabled { background: #555; cursor: not-allowed; opacity: 0.5; }
        .secondary-btn { background: #444; border: 1px solid #666; color: #ddd; padding: 8px 15px; border-radius: 8px; cursor: pointer; font-size: 12px; flex: 0.4; }

        .mode-btn { background: #444; border: 1px solid #fff; color: white; padding: 5px 10px; margin-bottom: 20px; cursor: pointer; border-radius: 5px; width: 90%; }

        /* HUD */
        .hud { display: flex; justify-content: space-between; padding: 10px 20px; height: 10%; pointer-events: none; }
        .hp-container { width: 40%; display: flex; flex-direction: column; }
        .hp-bar { width: 100%; height: 15px; background: #444; border: 2px solid white; margin-top: 5px; transform: skewX(-15deg); overflow: hidden; position: relative; }
        .hp-fill { height: 100%; transition: width 0.2s; }
        .p1-fill { background: #00aaff; width: 100%; }
        .p2-fill { background: #ff4444; width: 100%; }
        .status-text { font-size: 12px; color: yellow; margin-top: 5px; height: 20px; text-shadow: 1px 1px 0 #000; white-space: nowrap; }
        
        /* Character Specific UI */
        .ling-orbs { display: flex; gap: 3px; margin-top: 2px; }
        .ling-orb { width: 10px; height: 10px; border-radius: 50%; border: 1px solid #fff; background: #333; }
        .ling-orb.ready { background: #ffff00; box-shadow: 0 0 5px #ffff00; }
        .ember-bar { width: 100%; height: 5px; background: #333; margin-top: 2px; }
        .ember-fill { height: 100%; background: #ff5500; width: 0%; transition: width 0.1s; }
        .combo-text { font-size: 24px; font-weight: bold; font-style: italic; color: #ffcc00; text-shadow: 2px 2px 0 #ff0000; position: absolute; top: 100px; transition: transform 0.1s; opacity: 0; }
        #p1-combo { left: 10%; } #p2-combo { right: 10%; }

        /* Controls */
        .controls-layer { position: absolute; bottom: 0; left: 0; width: 100%; height: 100%; pointer-events: none; z-index: 50; }
        .touch-btn { position: absolute; border-radius: 50%; background: rgba(255, 255, 255, 0.15); border: 2px solid rgba(255, 255, 255, 0.3); pointer-events: auto; display: flex; justify-content: center; align-items: center; color: white; font-weight: bold; backdrop-filter: blur(2px); touch-action: none; transition: all 0.1s; }
        .touch-btn:active, .touch-btn.active { background: rgba(255, 255, 255, 0.4); transform: scale(0.95); }
        .cd-overlay { position: absolute; top:0; left:0; right:0; bottom:0; background: rgba(0,0,0,0.7); border-radius: 50%; display: none; justify-content: center; align-items: center; font-size: 14px; }

        /* P1 Layout */
        .p1-move-left { bottom: 30px; left: 20px; width: 60px; height: 60px; }
        .p1-move-right { bottom: 30px; left: 90px; width: 60px; height: 60px; }
        .p1-jump { bottom: 100px; left: 55px; width: 50px; height: 50px; background: rgba(0, 200, 255, 0.2); }
        .p1-dodge { bottom: 160px; left: 55px; width: 40px; height: 40px; background: rgba(255, 255, 0, 0.2); font-size: 10px;}
        .p1-atk { bottom: 30px; left: 220px; width: 65px; height: 65px; border-color: #ff9900; background: rgba(255,150,0,0.2); font-size: 12px;}
        .p1-s1 { bottom: 30px; left: 160px; width: 50px; height: 50px; border-color: #00aaff;}
        .p1-s2 { bottom: 90px; left: 180px; width: 50px; height: 50px; border-color: #00aaff;}
        .p1-s3 { bottom: 105px; left: 240px; width: 50px; height: 50px; border-color: #00aaff;}
        .p1-chat { bottom: 160px; left: 110px; width: 40px; height: 40px; border-color: #fff; background: rgba(100,100,255,0.4); font-size: 16px; }

        /* P2 Layout */
        .p2-move-right { bottom: 30px; right: 20px; width: 60px; height: 60px; }
        .p2-move-left { bottom: 30px; right: 90px; width: 60px; height: 60px; }
        .p2-jump { bottom: 100px; right: 55px; width: 50px; height: 50px; background: rgba(255, 100, 100, 0.2); }
        .p2-dodge { bottom: 160px; right: 55px; width: 40px; height: 40px; background: rgba(255, 255, 0, 0.2); font-size: 10px;}
        .p2-atk { bottom: 30px; right: 220px; width: 65px; height: 65px; border-color: #ff9900; background: rgba(255,150,0,0.2); font-size: 12px;}
        .p2-s1 { bottom: 30px; right: 160px; width: 50px; height: 50px; border-color: #ff4444;}
        .p2-s2 { bottom: 90px; right: 180px; width: 50px; height: 50px; border-color: #ff4444;}
        .p2-s3 { bottom: 105px; right: 240px; width: 50px; height: 50px; border-color: #ff4444;}
        .p2-chat { bottom: 160px; right: 110px; width: 40px; height: 40px; border-color: #fff; background: rgba(255,100,100,0.4); font-size: 16px; }

        .skill-label { font-size: 9px; position: absolute; bottom: -12px; width: 80px; text-align: center; text-shadow: 1px 1px 0 #000; pointer-events: none; left: -15px;}

        #game-over-msg { position: absolute; top: 50%; left: 50%; transform: translate(-50%, -50%); display: none; background: rgba(0,0,0,0.95); padding: 30px; border: 2px solid white; text-align: center; z-index: 90; pointer-events: auto; border-radius: 10px; min-width: 300px; }
        .restart-btn { background: #444; border: 2px solid #fff; padding: 10px 20px; color: white; margin-top: 15px; font-size: 16px; cursor: pointer; border-radius: 5px; }
        
        .ai-modal { position: fixed; top: 50%; left: 50%; transform: translate(-50%, -50%); width: 85%; max-width: 500px; background: #2d3748; border: 1px solid #4a5568; padding: 20px; z-index: 200; display: none; color: #e2e8f0; border-radius: 10px; box-shadow: 0 10px 30px rgba(0,0,0,0.5); max-height: 80vh; overflow-y: auto;}
        .ai-btn { background: linear-gradient(135deg, #667eea 0%, #764ba2 100%); border: none; color: white; padding: 8px 16px; border-radius: 20px; cursor: pointer; }

        @media (max-width: 600px) {
            #char-select-screen { flex-direction: column; }
            .select-left { width: 100%; height: 35%; border-right: none; border-bottom: 1px solid #444; }
            .select-right { width: 100%; height: 65%; }
        }
    </style>
</head>
<body>

<div id="game-container">
    <canvas id="gameCanvas"></canvas>

    <div id="char-select-screen" class="ui-layer">
        <div class="select-left">
            <h2 id="select-title">P1 (è—è‰²) è«‹é¸æ“‡</h2>
            <button id="mode-toggle" class="mode-btn" onclick="toggleMode()">æ¨¡å¼ï¼šé›™äººå°æˆ°</button>
            <div class="char-grid" id="char-grid"></div>
        </div>
        <div class="select-right">
            <div id="info-panel">
                <div id="info-name"></div>
                <div id="info-role"></div>
                <div id="info-desc"></div>
                <div class="skill-section-title">æŠ€èƒ½è©³æƒ…</div>
                <div id="info-skills"></div>
                <div class="btn-group">
                    <button id="confirm-btn" class="confirm-btn" onclick="confirmSelection()" disabled>é–å®šé¸æ“‡</button>
                    <button class="secondary-btn" onclick="askAiForTips()">âœ¨ AI æ”»ç•¥</button>
                    <button class="secondary-btn" onclick="showStatusGuide()">ğŸ“– ç‹€æ…‹åœ–é‘‘</button>
                </div>
            </div>
            <div id="info-placeholder" style="color:#666; text-align:center; margin-top:50%;">
                <div style="font-size:40px; margin-bottom:10px;">ğŸ‘†</div>
                é»æ“Šå·¦å´è§’è‰²é ­åƒ<br>æŸ¥çœ‹è©³ç´°æƒ…å ±èˆ‡æŠ€èƒ½
            </div>
        </div>
    </div>

    <div class="ui-layer">
        <div class="hud">
            <div class="hp-container">
                <div id="p1-name">Waiting...</div>
                <div class="hp-bar"><div id="p1-hp" class="hp-fill p1-fill"></div></div>
                <div id="p1-ember-bar" class="ember-bar" style="display:none;"><div id="p1-ember-fill" class="ember-fill"></div></div>
                <div id="p1-ling-bar" class="ling-orbs" style="display:none;">
                    <div class="ling-orb" id="p1-orb-0"></div><div class="ling-orb" id="p1-orb-1"></div><div class="ling-orb" id="p1-orb-2"></div>
                </div>
                <div id="p1-status" class="status-text"></div>
                <div id="p1-combo" class="combo-text"></div>
            </div>
            <div class="hp-container" style="align-items: flex-end;">
                <div id="p2-name">Waiting...</div>
                <div class="hp-bar"><div id="p2-hp" class="hp-fill p2-fill"></div></div>
                <div id="p2-ember-bar" class="ember-bar" style="display:none;"><div id="p2-ember-fill" class="ember-fill"></div></div>
                <div id="p2-ling-bar" class="ling-orbs" style="display:none;">
                    <div class="ling-orb" id="p2-orb-0"></div><div class="ling-orb" id="p2-orb-1"></div><div class="ling-orb" id="p2-orb-2"></div>
                </div>
                <div id="p2-status" class="status-text"></div>
                <div id="p2-combo" class="combo-text"></div>
            </div>
        </div>
    </div>

    <!-- Controls -->
    <div class="controls-layer" id="p1-controls" style="display:none;">
        <div class="touch-btn p1-move-left" data-key="p1-left">â†</div>
        <div class="touch-btn p1-move-right" data-key="p1-right">â†’</div>
        <div class="touch-btn p1-jump" data-key="p1-jump">è·³</div>
        <div class="touch-btn p1-dodge" data-key="p1-dodge">é–ƒ<div class="cd-overlay"></div></div>
        <div class="touch-btn p1-atk" data-key="p1-atk">æ”»</div>
        <div class="touch-btn p1-s1" data-key="p1-s0"><span class="skill-label">S1</span><div class="cd-overlay"></div></div>
        <div class="touch-btn p1-s2" data-key="p1-s1"><span class="skill-label">S2</span><div class="cd-overlay"></div></div>
        <div class="touch-btn p1-s3" data-key="p1-s2"><span class="skill-label">S3</span><div class="cd-overlay"></div></div>
        <div class="touch-btn p1-chat" onclick="triggerTaunt('p1')">ğŸ’¬</div>
    </div>

    <div class="controls-layer" id="p2-controls" style="display:none;">
        <div class="touch-btn p2-move-left" data-key="p2-left">â†</div>
        <div class="touch-btn p2-move-right" data-key="p2-right">â†’</div>
        <div class="touch-btn p2-jump" data-key="p2-jump">è·³</div>
        <div class="touch-btn p2-dodge" data-key="p2-dodge">é–ƒ<div class="cd-overlay"></div></div>
        <div class="touch-btn p2-atk" data-key="p2-atk">æ”»</div>
        <div class="touch-btn p2-s1" data-key="p2-s0"><span class="skill-label">S1</span><div class="cd-overlay"></div></div>
        <div class="touch-btn p2-s2" data-key="p2-s1"><span class="skill-label">S2</span><div class="cd-overlay"></div></div>
        <div class="touch-btn p2-s3" data-key="p2-s2"><span class="skill-label">S3</span><div class="cd-overlay"></div></div>
        <div class="touch-btn p2-chat" onclick="triggerTaunt('p2')">ğŸ’¬</div>
    </div>

    <div id="game-over-msg">
        <h2 id="winner-text">P1 Wins!</h2>
        <button class="ai-btn" onclick="generateBattleReport()">ğŸ“ AI è³½å¾Œè¬›è©•</button>
        <button class="restart-btn" onclick="resetGame()">é‡æ–°é–‹å§‹</button>
    </div>
    
    <div id="ai-modal" class="ai-modal">
        <div style="display:flex; justify-content:space-between; align-items:center;">
            <h3 style="margin:0; color:#a3bffa">èªªæ˜ / AI åˆ†æ</h3>
            <span style="cursor:pointer; font-size:24px;" onclick="document.getElementById('ai-modal').style.display='none'">Ã—</span>
        </div>
        <div id="ai-content" class="ai-content"></div>
    </div>
</div>

<script>
// --- Constants & Config ---
const apiKey = "";
async function callGemini(p) { 
    if(!apiKey) return "API Keyæœªè¨­å®š"; 
    try {
        const r=await fetch(`https://generativelanguage.googleapis.com/v1beta/models/gemini-2.5-flash-preview-09-2025:generateContent?key=${apiKey}`,{method:'POST',headers:{'Content-Type':'application/json'},body:JSON.stringify({contents:[{parts:[{text:p}]}]})});
        const d=await r.json();
        return d.candidates?.[0]?.content?.parts?.[0]?.text || "AI æš«æ™‚ç„¡æ³•å›æ‡‰...";
    } catch(e){ return "é€£ç·šéŒ¯èª¤ï¼Œè«‹æª¢æŸ¥ç¶²çµ¡ã€‚"; } 
}

const canvas = document.getElementById('gameCanvas');
const ctx = canvas.getContext('2d');
function resize() { canvas.width = window.innerWidth; canvas.height = window.innerHeight; }
window.addEventListener('resize', resize);
resize();

const GRAVITY = 0.6;
const GROUND_Y = canvas.height - 100;
const FRICTION = 0.8;
let shakeTimer = 0;

// --- Data ---
const STATUS_INFO = `
<div style="line-height:1.8;">
<b style="color:#ffcc00; font-size:18px;">ç‹€æ…‹åœ–é‘‘ (Status Guide)</b><br><hr style="border-color:#555;">
<b style="color:yellow;">ğŸ’« æšˆçœ© (Stun)</b>: ç„¡æ³•ç§»å‹•ã€æ”»æ“Šæˆ–ä½¿ç”¨æŠ€èƒ½ã€‚æ¥µåº¦å±éšªï¼Œæ˜“è¢«é€£æ‹›ã€‚<br>
<b style="color:#00ffff;">âš¡ å„²èƒ½ (Charge)</b>: æ­å§†å°ˆå±¬ã€‚å¸æ”¶å‚·å®³è½‰åŒ–çš„èƒ½é‡ï¼Œæ¯å±¤æå‡S2å‚·å®³èˆ‡S3çˆ†ç™¼ä¸Šé™ã€‚<br>
<b style="color:red;">â›” ç¦æ­¦ (Silence)</b>: å¡ä¿„æ–¯æ³•å‰‡ã€‚å…¨å ´ç„¡æ³•é€ æˆä»»ä½•å‚·å®³æˆ–æ²»ç™‚ï¼Œåƒ…èƒ½ç§»å‹•ã€‚æˆ°è¡“èª¿æ•´æœŸã€‚<br>
<b style="color:orange;">ğŸ’” æ˜“å‚· (Fragile/Vulnerable)</b>: å—åˆ°çš„å‚·å®³å¢åŠ  30% - 100%ã€‚é€šå¸¸ç”±å¡ä¿„æ–¯æ³•å‰‡æˆ–åŠè–ç ´ç”²é€ æˆã€‚<br>
<b style="color:#e6e6fa;">ğŸŒ€ æ··äº‚ (Chaos)</b>: å¡ä¿„æ–¯æ³•å‰‡ã€‚å·¦å³ç§»å‹•èˆ‡æŠ€èƒ½æŒ‰éµéš¨æ©Ÿåå‘æˆ–äº’æ›ã€‚<br>
<b style="color:orange;">ğŸ’¥ å´©è§£ (Meltdown)</b>: ç‡¼æ»…èƒ½é‡é”100%æ™‚å¼·åˆ¶è§¸ç™¼ã€‚è‡ªæˆ‘æšˆçœ©1.5ç§’ï¼Œæ¸…ç©ºèƒ½é‡ï¼Œä½†<b>é‡ç½®æ‰€æœ‰æŠ€èƒ½å†·å»</b>ã€‚<br>
<b style="color:gray;">ğŸ˜« è¡°ç«­ (Exhaust)</b>: ç‡¼æ»…S2çµæŸå¾Œè§¸ç™¼ã€‚ç§»å‹•é€Ÿåº¦æ¸›åŠï¼Œä¸”ç„¡æ³•ç²å¾—èƒ½é‡ã€‚<br>
<b style="color:purple;">â˜ ï¸ ä¸­æ¯’ (Poison)</b>: æ­»éˆæ³•å¸«æ–½åŠ ã€‚æ¯ç§’å—åˆ°æŒçºŒå‚·å®³ã€‚<br>
<b style="color:red;">ğŸ©¸ æµè¡€ (Bleed)</b>: çµé­”å¼“æ‰‹é™·é˜±æ–½åŠ ã€‚ç§»å‹•æ™‚æœƒå—åˆ°é¡å¤–å‚·å®³ã€‚<br>
<b style="color:gray;">ğŸ“‰ è™›å¼± (Weak)</b>: è–é¨å£«æ–½åŠ ã€‚é€ æˆçš„å‚·å®³é™ä½ 30%ã€‚<br>
<b style="color:orange;">ğŸ”¥ ç‡ƒç‡’ (Burn)</b>: çˆ†ç ´å°ˆå®¶æ–½åŠ ã€‚æŒçºŒå—åˆ°ç«ç„°å‚·å®³ã€‚<br>
<b style="color:cyan;">â„ï¸ ç·©é€Ÿ (Slow)</b>: ç§»å‹•é€Ÿåº¦é™ä½ 50%ã€‚<br>
<b style="color:cyan;">âš“ ç¸›ä»™ (Grounded)</b>: å‡Œéœ„å°ˆå±¬ã€‚ç„¡æ³•ä½¿ç”¨ä»»ä½•ä½ç§»æŠ€èƒ½ (åŒ…æ‹¬é–ƒé¿)ã€‚<br>
<b style="color:#fff;">ğŸ›¡ï¸ å …éŸŒ/ç„¡æ•µ (Defense/Inv)</b>: å—å‚·æ¸›å°‘æˆ–å…ç–«ã€‚é–ƒé¿æœŸé–“ç‚ºç„¡æ•µã€‚<br>
<b style="color:gray;">ğŸŒ æ·¤æ»¯ (Stasis)</b>: å‡Œéœ„çŸ­æ™‚é–“æ¶ˆè€—éå¤šä¸¹å…ƒå¾Œè§¸ç™¼ã€‚æ¸›é€Ÿä¸”ç„¡æ³•æ™®æ”»ã€‚<br>
<b style="color:#ff00ff;">ğŸ”— å®¿å‘½é€£çµ</b>: è¼ªè¿´å°ˆå±¬ã€‚å—åˆ°çš„å‚·å®³æœƒåŒæ­¥å‚³éçµ¦é€£çµçš„ç›®æ¨™ã€‚<br>
</div>
`;

const CHARACTERS = [
    {
        id: 'samsara', name: 'è¼ªè¿´ (Samsara)', icon: 'â˜¯ï¸', color: '#ffffff', weapon: 'staff', hp: 85, speed: 3.5,
        desc: 'å› æœæ‚–è«–çš„åŒ–èº«ã€‚ç”Ÿå‘½å€¼å³ç‚ºã€Œå› æœè² è·ã€ã€‚è¡€é‡è¶Šä½(è² è·è¶Šä½)ï¼ŒæŠ€èƒ½å†·å»è¶Šæ…¢ä½†å¦åº¦é«˜ï¼›è¡€é‡è¶Šé«˜(è² è·è¶Šé«˜)ï¼ŒæŠ€èƒ½å†·å»æ¥µå¿«ä½†æ¥µåº¦è„†å¼±ã€‚',
        skills: [
            { name: 'æ¥­ç«çºèº« (Q)', cd: 60, type: 'samsara_q', desc: 'å‘å‰æ–¹å™´å°„æ¥­ç«ã€‚å‚·å®³å–æ±ºæ–¼ç•¶å‰è¡€é‡è¶…é50%çš„éƒ¨åˆ†ã€‚é‡‹æ”¾å¾Œå¼·åˆ¶å°‡è¡€é‡é‡ç½®å›50%ã€‚' },
            { name: 'å‘½ç·šå›æº¯ (W)', cd: 480, type: 'samsara_w', desc: 'åˆ‡æ–·æ‰€æœ‰å› æœï¼Œè§£é™¤è‡ªèº«èˆ‡æ•µäººçš„æ‰€æœ‰ç‹€æ…‹ã€‚è‹¥æˆåŠŸè§£é™¤æ§åˆ¶ï¼Œå›å¾©è¡€é‡(å¢åŠ è² è·)ã€‚' },
            { name: 'å®¿å‘½ç½®æ› (E)', cd: 600, type: 'samsara_e', desc: 'é€£çµæ•µäººã€‚é›™æ–¹å—åˆ°çš„å‚·å®³å…±äº«ã€‚è‹¥åœ¨é€£çµæœŸé–“è¡€é‡å›å¾©è‡³90%ä»¥ä¸Šï¼Œè§¸ç™¼éè¼‰é€ æˆçˆ†ç™¼å‚·å®³ã€‚' }
        ]
    },
    {
        id: 'lingxiao', name: 'ä»™ç½¡å¾¡é¨ - å‡Œéœ„', icon: 'â˜ï¸', color: '#e6e6fa', weapon: 'staff', hp: 105, speed: 3.0,
        desc: 'ä¸€ä½ä»¥è‡ªèº«ç‚ºé™£çœ¼ï¼Œé€šéé‹è½‰ä¸¹å…ƒä¾†å¸ƒé™£çš„é‡å‹é£›è¡Œé¨å£«ã€‚èƒ½åœ¨é ç¨‹æ¶ˆè€—èˆ‡é™£åœ°æ¨é€²ä¸­åˆ‡æ›ã€‚æ“ä½œé›£åº¦æ¥µé«˜ï¼Œéœ€è¦ç²¾ç¢ºç®¡ç†ã€Œä¸¹å…ƒã€è³‡æºï¼Œé¿å…å› éå¿«æ¶ˆè€—è€Œé€²å…¥ã€Œæ·¤æ»¯ã€ç‹€æ…‹ã€‚',
        skills: [
            { name: 'ä¹éœ„å¢œæ˜Ÿé™£ (Q)', cd: 300, type: 'ling_q', desc: 'åœ¨æŒ‡å®šå€åŸŸå¸ƒé™£ï¼ŒçŸ­æš«å»¶é²å¾Œæ˜Ÿè¼å¢œè½ï¼Œé€ æˆä¸­ç­‰å‚·å®³ä¸¦æ–½åŠ ã€Œç¢ç”²ã€(é™é˜²)ã€‚' },
            { name: 'å‘¨å¤©è­·èº«é™£ (W)', cd: 480, type: 'ling_w', desc: 'åœ¨è…³ä¸‹å¸ƒä¸‹é˜²ç¦¦é™£ã€‚ç²å¾—30%æ¸›å‚·ä¸¦ç·©æ…¢å›è¡€(1%/s)ã€‚ç„¡ç§»é€ŸåŠ æˆã€‚' },
            { name: 'ç¸›ä»™é–éˆé™£ (E)', cd: 600, type: 'ling_e', desc: 'å°„å‡ºç¬¦å’’é–éˆå±•é–‹ã€Œç¸›ä»™é™£ã€ã€‚é™£å…§æ•µäººæ¸›é€Ÿä¸¦è¢«ã€Œç¦è¶³ã€(ç„¡æ³•ä½ç§»)ã€‚' }
        ]
    },
    {
        id: 'ember', name: 'å‡è¡¡æ¯€æ»…è€… - ç‡¼æ»…', icon: 'ğŸ”¥', color: '#ff5500', weapon: 'orb', hp: 100, speed: 3.2,
        desc: 'è¡Œèµ°åœ¨æ¯€æ»…é‚Šç·£çš„æ³•å¸«ã€‚æ ¸å¿ƒæ©Ÿåˆ¶æ˜¯ã€Œèƒ½é‡ç®¡ç†ã€ã€‚èƒ½é‡è¶Šé«˜æŠ€èƒ½è¶Šå¼·ï¼Œä½†è¶…é75%æœƒé€²å…¥å±éšªçš„ã€Œéè¼‰ã€ç‹€æ…‹(å—å‚·å¢åŠ )ï¼Œé”åˆ°100%æœƒã€Œå´©è§£ã€(æšˆçœ©)ã€‚é«˜é¢¨éšªï¼Œé«˜å›å ±ã€‚',
        skills: [
            { name: 'ä¸ç©©å®šè„ˆè¡ (Q)', cd: 180, type: 'ember_pulse', desc: 'ç™¼å°„ä¸€é“è„ˆè¡ã€‚å†æ¬¡æŒ‰ä¸‹Qå¯æ‰‹å‹•å¼•çˆ†é€ æˆæšˆçœ©ã€‚éè¼‰ç‹€æ…‹ä¸‹å¼•çˆ†å‚·å®³ç¿»å€ã€‚' },
            { name: 'èƒ½é‡éè¼‰ (W)', cd: 480, type: 'ember_overload_buff', desc: 'é–å®šç•¶å‰èƒ½é‡ç²å¾—è­·ç›¾èˆ‡å¢å‚·ã€‚æ•ˆæœçµæŸå¾Œé€²å…¥ã€Œè¡°ç«­ã€ç‹€æ…‹(æ¸›é€Ÿã€ç„¡æ³•å›èƒ½)ã€‚' },
            { name: 'è™›ç©ºå¥‡é» (E)', cd: 600, type: 'ember_singularity', desc: 'å‰µé€ å¥‡é»é»‘æ´ï¼Œå¸é™„æ•µäººä¸¦ç‚ºè‡ªèº«å›å¾©èƒ½é‡ã€‚å¯ç”¨QæŠ€èƒ½å¼•çˆ†å¥‡é»ã€‚' }
        ]
    },
    {
        id: 'khaos', name: 'è¬è±¡ç·¨ç¹”è€… - å¡ä¿„æ–¯', icon: 'ğŸŒ€', color: '#ff00ff', weapon: 'orb', hp: 90, speed: 3.2,
        desc: 'è¦å‰‡çš„åŒ–èº«ã€‚ä»–ä¸ç›´æ¥ä¾é è »åŠ›ï¼Œè€Œæ˜¯é€šéç¯¡æ”¹æˆ°å ´è¦å‰‡ä¾†å–å‹ã€‚æ“æœ‰ç¨ç‰¹çš„ã€Œè¬è±¡å„€ã€ç³»çµ±ï¼Œä¸åŒæŠ€èƒ½æœƒæ”¹è®Šç•¶å‰ç”Ÿæ•ˆçš„ã€Œå› ã€æœã€å¾‹ã€æ³•å‰‡ã€‚æ“ä½œé›£åº¦æ¥µé«˜ã€‚',
        skills: [
            { name: 'å› æœç¯¡æ”¹ (Q)', cd: 240, type: 'khaos_link', desc: 'é€£çµå°æ‰‹ã€‚ã€Œå› ã€ä¸»å°æ™‚å¸è¡€ï¼Œã€Œæœã€ä¸»å°æ™‚åå½ˆå‚·å®³ã€‚' },
            { name: 'å®šå¾‹è¦†å¯« (W)', cd: 360, type: 'khaos_field', desc: 'å‰µé€ æ‚–è«–é ˜åŸŸã€‚é ˜åŸŸå…§ç§»å‹•åå‘ï¼Œæˆ–å‚·å®³/æ²»ç™‚æ•ˆæœäº’æ›ã€‚' },
            { name: 'è¬è±¡æ­¸å¯‚ (E)', cd: 900, type: 'khaos_ult', desc: 'çµ‚æ¥µæŠ€èƒ½ã€‚æ ¹æ“šæœ€é«˜èƒ½é‡ç’°ï¼Œå¼·åˆ¶å…¨å ´ç¦æ­¦(å› )ã€å…¨å“¡æ˜“å‚·(æœ)æˆ–æŒ‰éµäº‚åº(å¾‹)ã€‚' }
        ]
    },
    {
        id: 'ohm', name: 'èƒ½é‡å°é«” - æ­å§†', icon: 'ğŸ”‹', color: '#00ffff', weapon: 'orb', hp: 100, speed: 3.2,
        desc: 'é˜²å®ˆåæ“Šå¤§å¸«ã€‚æœ¬èº«ä¸ç”¢ç”Ÿèƒ½é‡ï¼Œä¾é å¸æ”¶å°æ‰‹æ”»æ“Šä¾†åæ“Šã€‚æ ¸å¿ƒåœ¨æ–¼æŠ“æº–æ™‚æ©Ÿé–‹å•Ÿè­·ç›¾å¸æ”¶å‚·å®³ï¼Œè½‰åŒ–ç‚ºå„²èƒ½å±¤æ•¸ï¼Œå†é€²è¡Œçˆ†ç™¼ã€‚',
        skills: [ 
            { name: 'èƒ½é‡å¸æ”¶ (Q)', cd: 480, type: 'ohm_absorb', desc: 'å±•é–‹çµ•å°é˜²ç¦¦è­·ç›¾1.5ç§’ã€‚æœŸé–“å…ç–«å‚·å®³ï¼Œä¸¦å°‡å—åˆ°çš„æŠ€èƒ½å‚·å®³è½‰åŒ–ç‚ºã€Œå„²èƒ½ã€ã€‚' }, 
            { name: 'èƒ½é‡é‡‹æ”¾ (W)', cd: 120, type: 'ohm_release', desc: 'æ¶ˆè€—ä¸€å±¤å„²èƒ½ï¼Œç™¼å°„è¿½è¹¤èƒ½é‡å½ˆã€‚å‚·å®³éš¨å„²èƒ½å±¤æ•¸å¢åŠ ã€‚' }, 
            { name: 'éè¼‰çˆ†ç™¼ (E)', cd: 600, type: 'ohm_overload', desc: 'å¼•çˆ†æ‰€æœ‰å„²èƒ½ï¼Œå°å‘¨åœé€ æˆæ¯€æ»…æ€§æ‰“æ“Š(æœ€é«˜é€ æˆæ•µæ–¹50%è¡€é‡å‚·å®³)ã€‚' } 
        ]
    },
    { id: 'knox', name: 'æ··æ²Œè¡“å£« - è«¾å…‹æ–¯', icon: 'ğŸ²', color: '#00ffaa', weapon: 'staff', hp: 90, speed: 3.2, desc: 'ç™¡è¿·æ–¼éš¨æ©Ÿçš„ç˜‹ç‹‚æ³•å¸«ã€‚æŠ€èƒ½æ•ˆæœå®Œå…¨éš¨æ©Ÿï¼Œå¯èƒ½ç§’æ®ºå°æ‰‹ï¼Œä¹Ÿå¯èƒ½å‘äº†è‡ªå·±ã€‚', skills: [ {name:'æ··æ²Œé£›å½ˆ', cd:150, type: 'chaos_missile', desc:'è»Œè·¡éš¨æ©Ÿçš„é£›å½ˆï¼Œå‘½ä¸­æ•ˆæœéš¨æ©Ÿ(æšˆçœ©/æš´æ“Š/å¹«æ•µäººå›è¡€!)'}, {name:'å‘½é‹è½‰ç§»', cd:300, type: 'chaos_shift', desc:'å‰µé€ æ¼©æ¸¦ã€‚å¸æ”¶é£›è¡Œé“å…·åæ“Šï¼Œæˆ–èˆ‡æ•µäººå¼·åˆ¶äº¤æ›ä½ç½®ã€‚'}, {name:'ç‹‚äº‚å¬å–š', cd:500, type: 'chaos_summon', desc:'éš¨æ©Ÿå¬å–šç”Ÿç‰©ï¼šå²èŠå§†ã€å°æƒ¡é­”ã€å¯¶ç®±(ç‚¸å½ˆ?)ã€æˆ–è½é›·ã€‚'} ] },
    { id: 'sera', name: 'è™›ç©ºè³½æ‹‰', icon: 'ğŸ”®', color: '#bd00ff', weapon: 'orb', hp: 90, speed: 3.8, desc: 'ç©¿æ¢­æ–¼è™›ç©ºçš„åˆºå®¢ã€‚æ“æœ‰æ¥µé«˜çš„æ©Ÿå‹•æ€§ï¼Œåˆ©ç”¨æ®˜å½±è¿·æƒ‘å°æ‰‹ï¼Œä¸¦å…·å‚™å…¨åœ–ç›´ç·šè²«ç©¿èƒ½åŠ›ã€‚', skills: [ {name:'è™›ç©ºç½®æ›', cd:180, type: 'void_swap', desc:'ç¬é–“èˆ‡å ´ä¸Šçš„ä¸€å€‹æ®˜å½±äº¤æ›ä½ç½®ã€‚'}, {name:'è™›ç©ºç©¿åˆº', cd:240, type: 'void_beam', damage:25, desc:'ç™¼å°„ä¸€é“ç„¡é™è·é›¢çš„è™›ç©ºé›·å°„ï¼Œé€ æˆç›´ç·šå‚·å®³ã€‚'}, {name:'é¡åƒè¿´éŸ¿', cd:480, type: 'void_echo', desc:'å‘½ä»¤æ‰€æœ‰æ®˜å½±æ¨¡ä»¿æœ¬é«”ä¸Šä¸€æ¬¡ä½¿ç”¨çš„æŠ€èƒ½ã€‚'} ] },
    { id: 'blade', name: 'ç–¾é¢¨åŠè–', icon: 'âš”ï¸', color: '#33ccff', weapon: 'sword', hp: 100, speed: 3.2, desc: 'å‚³çµ±è¿‘æˆ°å¼·è€…ã€‚æ“æœ‰å„ªç§€çš„çªé€²èˆ‡ç¯„åœå‚·å®³èƒ½åŠ›ï¼Œé©åˆæ–°æ‰‹èˆ‡é€²éšç©å®¶ã€‚', skills: [ {name:'å±…åˆæ–¬', cd:120, type: 'dash_dmg', damage:25, desc:'å¿«é€Ÿå‘å‰çªé€²ä¸¦æ–¬æ“Šï¼Œé€ æˆå‚·å®³ã€‚'}, {name:'åŠåˆƒé¢¨æš´', cd:300, type: 'aoe_self', radius:120, damage:30, desc:'æ—‹è½‰åŠåˆƒæ”»æ“Šå‘¨åœæ•µäººï¼Œæ–½åŠ ã€Œç ´ç”²ã€æ•ˆæœã€‚'}, {name:'å¿ƒçœ¼', cd:400, type: 'buff', buffType: 'counter', duration:60, desc:'é€²å…¥æ‹›æ¶å§¿æ…‹ï¼Œåå½ˆä¸‹ä¸€æ¬¡å—åˆ°çš„å‚·å®³ã€‚'} ] },
    { id: 'archer', name: 'çµé­”å¼“æ‰‹', icon: 'ğŸ¹', color: '#99ff33', weapon: 'bow', hp: 85, speed: 3.8, desc: 'éˆæ´»çš„é ç¨‹è¼¸å‡ºã€‚æ“…é•·åˆ©ç”¨é™·é˜±é™åˆ¶å°æ‰‹èµ°ä½ï¼Œä¸¦é€éé¢¨ç®æˆ°è¡“æ¶ˆè€—æ•µäººã€‚', skills: [ {name:'å¤šé‡å°„æ“Š', cd:100, type: 'proj_multi', damage:8, desc:'æ‰‡å½¢å°„å‡ºäº”æ”¯ç®­çŸ¢ã€‚'}, {name:'æ•ç¸å¤¾', cd:300, type: 'trap', damage:15, duration:300, desc:'æ”¾ç½®éš±å½¢é™·é˜±ï¼Œè¸©ä¸­è€…æšˆçœ©ä¸¦ã€Œæµè¡€ã€ã€‚'}, {name:'å¾Œè·³å°„æ“Š', cd:240, type: 'evade_shot', damage:20, desc:'å‘å¾Œè·³èºæ‹‰é–‹è·é›¢ï¼ŒåŒæ™‚å°„å‡ºä¸€ç®­ã€‚'} ] },
    { id: 'paladin', name: 'è–å…‰é¨å£«', icon: 'ğŸ›¡ï¸', color: '#ffcc00', weapon: 'hammer', hp: 120, speed: 2.8, desc: 'å …ä¸å¯æ‘§çš„å¦å…‹ã€‚æ“æœ‰æœ€é«˜çš„ç”Ÿå‘½å€¼å’Œè‡ªæˆ‘æ²»ç™‚èƒ½åŠ›ï¼Œæ“…é•·æŒä¹…æˆ°ã€‚', skills: [ {name:'æ­£ç¾©ä¹‹éŒ˜', cd:150, type: 'proj_heavy', damage:20, desc:'æ‹‹ç‰©ç·šæŠ•æ“²éŒ˜å­ï¼Œé€ æˆç¯„åœå‚·å®³ã€‚'}, {name:'è–å…‰æ²»ç™’', cd:600, type: 'heal', amount:25, desc:'å›å¾©è‡ªèº«ç”Ÿå‘½å€¼ï¼Œä¸¦ç²å¾—çŸ­æš«ã€Œå …éŸŒã€(æ¸›å‚·)ã€‚'}, {name:'å¯©åˆ¤é ˜åŸŸ', cd:600, type: 'aoe_ground', damage:20, desc:'é‡æ“Šåœ°é¢ï¼Œå°å‘¨åœæ•µäººé€ æˆå‚·å®³ä¸¦æ–½åŠ ã€Œè™›å¼±ã€ã€‚ç¯„åœå¢å¤§ã€‚'} ] },
    { id: 'bomber', name: 'çˆ†ç ´å°ˆå®¶', icon: 'ğŸ’£', color: '#ff6600', weapon: 'bomb', hp: 95, speed: 3.2, desc: 'ç¯„åœå‚·å®³å°ˆå®¶ã€‚æ‰€æœ‰æŠ€èƒ½éƒ½å¸¶æœ‰çˆ†ç‚¸æ•ˆæœï¼Œèƒ½é€ æˆå¤§é¢ç©å£“åˆ¶ã€‚', skills: [ {name:'å®šæ™‚ç‚¸å½ˆ', cd:180, type: 'proj_bomb', damage:25, desc:'æŠ•æ“²ä¸€é¡†å»¶æ™‚ç‚¸å½ˆï¼Œçˆ†ç‚¸é€ æˆã€Œç‡ƒç‡’ã€ã€‚'}, {name:'ç«ç®­è·³', cd:240, type: 'jump_atk', damage:15, desc:'åˆ©ç”¨çˆ†ç‚¸åè¡åŠ›é«˜é«˜è·³èµ·ï¼Œè½åœ°é€ æˆå‚·å®³ã€‚'}, {name:'è‡ªçˆ†ç„¡äººæ©Ÿ', cd:500, type: 'summon_drone', damage:35, desc:'é‡‹æ”¾è‡ªå‹•è¿½è¹¤æ•µäººçš„ç„¡äººæ©Ÿã€‚'} ] },
    { id: 'necro', name: 'æ­»éˆæ³•å¸«', icon: 'ğŸ’€', color: '#aa00ff', weapon: 'staff', hp: 90, speed: 3.0, desc: 'æŠ˜ç£¨æ•µäººçš„é»‘æ³•å¸«ã€‚æ“…é•·å¬å–šåƒ•å¾å¹²æ“¾å°æ‰‹ï¼Œä¸¦é€šéæ¯’ç´ å’Œå¸è¡€å‰Šå¼±æ•µäººã€‚', skills: [ {name:'éˆé­‚ç«', cd:80, type: 'proj_homing', damage:12, desc:'ç™¼å°„è¿½è¹¤éˆé­‚å½ˆï¼Œå‘½ä¸­æ–½åŠ ã€Œä¸­æ¯’ã€ã€‚'}, {name:'å¬å–šéª·é«', cd:600, type: 'summon', hp:30, damage:5, desc:'å¾åœ°åº•å¬å–šéª·é«å…µå”åŠ©æˆ°é¬¥ã€‚'}, {name:'ç”Ÿå‘½æ±²å–', cd:400, type: 'drain', range:300, damage:20, desc:'æŒçºŒå¸å–è¿‘èº«æ•µäººçš„ç”Ÿå‘½å€¼ã€‚'} ] },
    { id: 'assassin', name: 'å¹»å½±åˆºå®¢', icon: 'ğŸ¥·', color: '#cccccc', weapon: 'sword', hp: 80, speed: 4.2, desc: 'é«˜çˆ†ç™¼çš„è„†çš®æ®ºæ‰‹ã€‚æ“æœ‰æ¥µé«˜çš„é€Ÿåº¦å’Œç¬ç§»èƒ½åŠ›ï¼Œè¿½æ±‚ä¸€æ“Šå¿…æ®ºã€‚', skills: [ {name:'è‹¦ç„¡', cd:50, type: 'proj_fast', damage:8, desc:'å¿«é€ŸæŠ•æ“²é›™é‡è‹¦ç„¡ï¼Œé€ æˆã€Œç·©é€Ÿã€ã€‚'}, {name:'å½±åˆ†èº«', cd:300, type: 'clone', duration:180, desc:'è£½é€ ä¸€å€‹éœæ­¢çš„åˆ†èº«è¿·æƒ‘å°æ‰‹ã€‚'}, {name:'ç¬æ­¥', cd:360, type: 'teleport_back', damage:30, desc:'ç¬é–“ç§»å‹•åˆ°æ•µäººèƒŒå¾Œé€²è¡Œé«˜å‚·èƒŒåˆºã€‚'} ] }
];

// --- Global Vars ---
let players = [], projectiles = [], effects = [], floatingTexts = [], gameState = 'SELECT';
let p1CharIndex = -1, p2CharIndex = -1, turn = 'P1', isPvE = false;
let inputState = { p1: {}, p2: {} };
let globalRule = null; 
let globalRuleTimer = 0;
let activeTimers = [];
let gameLoopId = null;

// --- Classes ---
class GameObject { constructor(x,y,c){this.x=x;this.y=y;this.color=c;this.marked=false;} }

class FloatingText {
    constructor(x, y, text, color, life=60) {
        this.x = x; this.y = y; this.text = text; this.color = color; this.life = life; this.vy = -1;
    }
    update() { this.y += this.vy; this.life--; }
    draw(ctx) {
        ctx.globalAlpha = Math.max(0, this.life/60);
        ctx.fillStyle = this.color; ctx.font = "bold 16px Arial"; ctx.textAlign = "center";
        ctx.fillText(this.text, this.x, this.y);
        ctx.globalAlpha = 1.0;
    }
}

class Particle extends GameObject {
    constructor(x, y, color, vx, vy, size, life) { super(x, y, color); this.vx = vx; this.vy = vy; this.size = size; this.life = life; this.maxLife = life; }
    update() { this.x += this.vx; this.y += this.vy; this.life--; this.size *= 0.95; if(this.life <= 0) this.marked=true; }
    draw(ctx) { ctx.globalAlpha = this.life / this.maxLife; ctx.fillStyle = this.color; ctx.beginPath(); ctx.arc(this.x, this.y, this.size, 0, Math.PI*2); ctx.fill(); ctx.globalAlpha = 1.0; }
}

class Player {
    constructor(id, x, data) {
        this.id = id; this.x = x; this.y = GROUND_Y; this.vx = 0; this.vy = 0;
        this.data = data; this.hp = data.hp; this.maxHp = data.hp; this.color = data.color;
        this.facingRight = id === 'p1'; this.cooldowns = [0,0,0]; this.atkCd = 0;
        this.stunTimer = 0; this.invincible = 0; this.buffs = [];
        this.aiTimer = 0; this.inputAI = {left:false,right:false,jump:false};
        
        // Character Specifics
        this.rings = [0, 0, 0]; this.causalLink = false; // Khaos
        this.ohmStorage = 0; this.isAbsorbing = false; // Ohm
        this.remnantTimer = 0; // Sera
        
        // Ember Specifics
        this.energy = 0; // 0-100
        this.exhaustionTimer = 0;
        this.overloadBuff = 0; // dmg mult %
        this.emberPulseActive = false; // track for detonation
        
        // Ling Xiao Specifics
        this.danyuan = 3; 
        this.danyuanTimers = [0, 0, 0]; // Timers for each orb
        this.stasisTimer = 0; 
        this.lingRecentUsage = []; // timestamps
        this.xiangangStacks = 0;
        this.xiangangTimer = 0;
        
        // Samsara Specifics
        if (this.data.id === 'samsara') {
            this.hp = 85; // Initial Load
            this.maxHp = 100; // Max Load
        }

        // Combo
        this.combo = 0; this.comboTimer = 0;
    }

    update() {
        if(this.hp <= 0) return;
        
        // Safety Check for NaN
        if (isNaN(this.x) || isNaN(this.y)) { this.x = this.id==='p1'?100:canvas.width-100; this.y = GROUND_Y; this.vx=0; this.vy=0; }

        if (isPvE && this.id === 'p2' && this.stunTimer <= 0) this.updateAI();

        let inp = (isPvE && this.id==='p2') ? this.inputAI : (inputState[this.id] || {});
        
        const paradox = effects.find(e => e instanceof Trap && e.type === 'khaos_field');
        let moveLeft = inp.left, moveRight = inp.right;
        if (paradox && Math.abs(this.x - paradox.x) < 150 && this.data.id !== 'khaos' && paradox.subType === 'law') {
             if (Math.floor(Date.now()/500) % 2 === 0) { moveLeft = inp.right; moveRight = inp.left; }
        }

        if(this.stunTimer > 0) {
            this.stunTimer--; 
            if(this.stunTimer===0 && this.data.id==='sera') this.spawnRemnant(); 
        } else {
            let speedMod = 1.0;
            // Status Slow
            if (this.buffs.find(b=>b.type==='slow_short')) speedMod = 0.5;
            if (this.buffs.find(b=>b.type==='grounded')) speedMod = 0.6;

            // Ember Exhaustion Slow
            if (this.data.id === 'ember') {
                if (this.exhaustionTimer > 0) { 
                    this.exhaustionTimer--; 
                    speedMod = 0.5; 
                } else if (this.energy < 100) {
                    this.energy = Math.min(100, this.energy + 0.08); 
                }
                
                if (this.energy >= 100 && this.stunTimer <= 0 && this.exhaustionTimer <= 0) {
                    this.stunTimer = 90; 
                    this.energy = 0;
                    this.cooldowns = [0,0,0]; 
                    floatingTexts.push(new FloatingText(this.x, this.y-50, "ğŸ’¥ MELTDOWN!", "red"));
                    createExplosion(this.x, this.y-30, 'orange', 20);
                    shakeScreen();
                }
            }
            
            // Ling Xiao Stasis
            if (this.data.id === 'lingxiao') {
                if (this.stasisTimer > 0) { this.stasisTimer--; speedMod = 0.8; }
                // Danyuan Recharge
                for(let i=0; i<3; i++) {
                    if (this.danyuanTimers[i] > 0) {
                        this.danyuanTimers[i]--;
                        if (this.danyuanTimers[i] <= 0) this.danyuan++;
                    }
                }
                // Xiangang Decay
                if(this.xiangangTimer > 0) {
                    this.xiangangTimer--;
                    if(this.xiangangTimer <= 0) this.xiangangStacks = 0;
                }
                // Passive 2: Resonance
                let allOnCd = true;
                for(let i=0; i<3; i++) if (this.danyuanTimers[i] <= 0) allOnCd = false;
                if (allOnCd && this.cooldowns[0] > 0) { 
                     this.buffs.push({type: 'defense_up', timer: 180}); 
                     this.cooldowns[0] = 0; 
                     floatingTexts.push(new FloatingText(this.x, this.y-60, "RESONANCE!", "#e6e6fa"));
                     updateCd(this.id, 0, 0); 
                }
            }

            if(moveLeft) { this.vx -= 1; this.facingRight = false; }
            if(moveRight) { this.vx += 1; this.facingRight = true; }
            if(inp.jump && this.y >= GROUND_Y) { this.vy = -12; if(this.data.id==='sera') this.spawnRemnant(); }
            
            const limit = this.data.speed * speedMod;
            this.vx = Math.max(-limit, Math.min(limit, this.vx));
        }
        
        this.vy += GRAVITY; this.vx *= FRICTION; this.x += this.vx; this.y += this.vy;
        if(this.y > GROUND_Y) { this.y = GROUND_Y; this.vy = 0; }
        if(this.x < 20) this.x = 20; if(this.x > canvas.width-20) this.x = canvas.width-20;
        
        let cdRate = 1;
        if (paradox && Math.abs(this.x - paradox.x) < 150 && paradox.subType === 'cause') cdRate = 2; 
        if (globalRule === 'silence') cdRate = 0.5; 
        
        // Samsara CD Logic (Decay Buff)
        if (this.data.id === 'samsara') {
            if (this.hp > 50) {
                cdRate = 1 + (this.hp - 50) * 0.04; // Up to 3.0x
            } else {
                cdRate = 0.5; // Sluggish when tanky
            }
            // Drift to 50 (Slower decay for buff)
            if (this.hp > 50) this.hp -= 0.02;
            else if (this.hp < 50) this.hp += 0.02;
        }

        this.cooldowns = this.cooldowns.map(c => c > 0 ? c - cdRate : 0);
        if(this.atkCd > 0) this.atkCd--;
        if(this.invincible > 0) this.invincible--;
        
        this.buffs = this.buffs.filter(b => {
            b.timer--;
            if (b.timer % 60 === 0) {
                if (b.type === 'poison') this.takeDamage(3, null, 'dot');
                if (b.type === 'bleed' && Math.abs(this.vx) > 1) this.takeDamage(5, null, 'dot');
                if (b.type === 'burn') this.takeDamage(4, null, 'dot');
                // Ling Xiao W Regen (nerfed to 1 per tick)
                if (b.type === 'ling_regen') this.heal(1); 
            }
            return b.timer > 0;
        });

        if(this.causalLink) this.causalLink--; 
        if(this.comboTimer > 0) { this.comboTimer--; if(this.comboTimer<=0) this.combo=0; }

        if (this.data.id === 'sera' && Math.abs(this.vx) > 3 && ++this.remnantTimer > 60) {
            this.spawnRemnant(); this.remnantTimer = 0;
        }
    }

    updateAI() {
        this.aiTimer++;
        if (this.aiTimer < 30) return; 
        if (this.aiTimer % 30 === 0) {
            const enemy = players.find(p => p.id !== this.id);
            if(!enemy) return;
            const dist = Math.abs(this.x - enemy.x);
            this.facingRight = enemy.x > this.x;
            if (dist > 200) this.inputAI = {left: !this.facingRight, right: this.facingRight, jump: false};
            else if (dist < 100) this.inputAI = {left: this.facingRight, right: !this.facingRight, jump: Math.random()<0.3};
            else this.inputAI = {left: false, right: false, jump: false};
            
            if (this.data.id === 'ember' && this.energy >= 75 && this.cooldowns[0]<=0) this.useSkill(0); 
            if (this.data.id === 'lingxiao' && this.danyuan > 0 && Math.random() < 0.5) this.useSkill(Math.floor(Math.random()*3));
            if (this.data.id === 'samsara') { if(this.hp > 60) this.useSkill(0); }

            if (Math.random() < 0.4) {
                const sIdx = Math.floor(Math.random()*3);
                if (this.cooldowns[sIdx] <= 0) this.useSkill(sIdx);
                else if (dist < 100 && this.atkCd <= 0) this.basicAttack();
            }
        }
    }

    addCombo() {
        this.combo++;
        this.comboTimer = 120; 
        const el = document.getElementById(this.id + '-combo');
        el.innerText = this.combo + " HITS!";
        el.style.opacity = 1;
        el.style.transform = "scale(1.5)";
        setTimeout(() => el.style.transform = "scale(1)", 100);
        setTimeout(() => { if(this.comboTimer<=0) el.style.opacity=0; }, 2000);
        
        if (this.data.id === 'lingxiao' && this.xiangangStacks < 4) {
            this.xiangangStacks++;
            this.xiangangTimer = 300; 
            floatingTexts.push(new FloatingText(this.x, this.y-70, `ä»™ç½¡ x${this.xiangangStacks}`, "#e6e6fa"));
        }
    }

    draw(ctx) {
        if(this.hp <= 0) return;
        if(this.invincible > 0 && Math.floor(Date.now()/50)%2===0) return;
        const hw = this.facingRight ? 1 : -1;
        
        if (this.isAbsorbing) {
            ctx.save(); ctx.strokeStyle = '#00ffff'; ctx.lineWidth = 3; ctx.setLineDash([5, 5]); ctx.beginPath(); ctx.arc(this.x, this.y-30, 45, 0, Math.PI*2); ctx.stroke(); ctx.fillStyle = 'rgba(0, 255, 255, 0.2)'; ctx.fill(); ctx.restore();
        }

        ctx.save(); ctx.strokeStyle = '#fff'; ctx.lineWidth = 2;
        const hx = this.x + hw*15, hy = this.y-30;
        // Weapon
        if(this.data.weapon === 'sword') { ctx.beginPath(); ctx.moveTo(hx, hy); ctx.lineTo(hx+hw*30, hy-10); ctx.stroke(); }
        else if(this.data.weapon === 'bow') { ctx.beginPath(); ctx.arc(hx+hw*10, hy, 15, -1.5, 1.5, this.facingRight); ctx.stroke(); }
        else if(this.data.weapon === 'staff' || this.data.weapon === 'orb') { ctx.beginPath(); ctx.arc(hx+hw*10, hy-10, 5, 0, Math.PI*2); ctx.fillStyle = this.color; ctx.fill(); }
        else if(this.data.weapon === 'hammer') { ctx.fillStyle='#888'; ctx.fillRect(hx+hw*10, hy-20, 20, 15); }
        ctx.restore();

        ctx.strokeStyle = this.color; ctx.lineWidth = 4;
        ctx.beginPath(); ctx.arc(this.x, this.y-60, 10, 0, Math.PI*2);
        ctx.moveTo(this.x, this.y-50); ctx.lineTo(this.x, this.y-25);
        ctx.moveTo(this.x, this.y-25); ctx.lineTo(this.x-10, this.y);
        ctx.moveTo(this.x, this.y-25); ctx.lineTo(this.x+10, this.y);
        ctx.moveTo(this.x, this.y-50); ctx.lineTo(hx, hy);
        ctx.stroke();
        
        if(this.stunTimer>0) ctx.fillText('ğŸ’«', this.x-5, this.y-80);
        if(this.causalLink) { ctx.strokeStyle='red'; ctx.beginPath(); ctx.moveTo(this.x, this.y-60); const e=players.find(p=>p.id!==this.id); if(e) ctx.lineTo(e.x, e.y-60); ctx.stroke(); }
        if(this.data.id==='khaos') this.drawRings(ctx);
        if (this.buffs.find(b=>b.type==='fate_link')) { ctx.strokeStyle='white'; ctx.setLineDash([2,2]); ctx.beginPath(); ctx.moveTo(this.x, this.y-40); const e=players.find(p=>p.id!==this.id); ctx.lineTo(e.x, e.y-40); ctx.stroke(); ctx.setLineDash([]); }
        
        const statusEl = document.getElementById(this.id + '-status');
        let statusStr = "";
        if (this.data.id === 'ohm') statusStr += 'âš¡'.repeat(this.ohmStorage);
        if (this.data.id === 'ember') {
            if (this.energy > 75) statusStr += " [OVERLOAD] ";
            if (this.exhaustionTimer > 0) statusStr += " [EXHAUST] ";
            const bar = document.getElementById(this.id+'-ember-fill');
            const container = document.getElementById(this.id+'-ember-bar');
            if(container) {
                container.style.display = 'block';
                bar.style.width = this.energy + '%';
                bar.style.backgroundColor = this.energy > 75 ? 'red' : '#ff5500';
            }
        }
        if (this.data.id === 'lingxiao') {
            if (this.stasisTimer > 0) statusStr += " [ğŸŒ]";
            if (this.xiangangStacks > 0) statusStr += ` [âœ¨x${this.xiangangStacks}]`;
            const cont = document.getElementById(this.id+'-ling-bar');
            cont.style.display = 'flex';
            for(let i=0; i<3; i++) {
                const orb = document.getElementById(`${this.id}-orb-${i}`);
                if (this.danyuanTimers[i] <= 0) orb.classList.add('ready');
                else orb.classList.remove('ready');
            }
        }
        if (this.data.id === 'samsara') {
            statusStr += ` [LOAD: ${Math.floor(this.hp)}%]`;
        }

        if (this.isAbsorbing) statusStr += " [ABSORB]";
        if (this.invincible>0) statusStr += " [INV]";
        this.buffs.forEach(b => {
            if(b.type==='poison') statusStr += " [â˜ ï¸]";
            if(b.type==='weak') statusStr += " [ğŸ“‰]";
            if(b.type==='bleed') statusStr += " [ğŸ©¸]";
            if(b.type==='burn') statusStr += " [ğŸ”¥]";
            if(b.type==='slow_short' || b.type==='grounded') statusStr += " [â„ï¸]";
            if(b.type==='defense_up') statusStr += " [ğŸ›¡ï¸]";
            if(b.type==='vulnerable' || b.type==='shatter') statusStr += " [ğŸ’”]";
            if(b.type==='fate_link') statusStr += " [ğŸ”—]";
        });
        statusEl.innerText = statusStr;
    }

    drawRings(ctx) {
        const cols = ['red', 'lime', 'blue'];
        for(let i=0; i<3; i++) {
            ctx.fillStyle = cols[i];
            const h = (this.rings[i] / 100) * 10;
            ctx.fillRect(this.x - 20 + i*15, this.y - 90 - h, 10, h);
            ctx.strokeRect(this.x - 20 + i*15, this.y - 100, 10, 10);
        }
    }

    basicAttack() {
        if(this.atkCd > 0 || this.stunTimer > 0 || this.isAbsorbing || this.stasisTimer > 0) return;
        this.atkCd = 30;
        const enemy = players.find(p=>p.id!==this.id);
        if(enemy) this.facingRight = enemy.x > this.x; 
        const dir = this.facingRight ? 1 : -1;
        if (globalRule === 'silence') return; 

        if (this.data.id === 'necro' && enemy) enemy.applyStatus('poison', 180);
        if (this.data.id === 'paladin' && enemy) enemy.applyStatus('weak', 180);

        if(['sword','hammer'].includes(this.data.weapon) || this.data.id === 'assassin') {
            createExplosion(this.x+dir*30, this.y-30, '#fff', 5);
            projectiles.push(new Projectile(this.id, this.x+dir*30, this.y-30, dir*12, 0, {type:'sword_wave', damage:6, color:this.color, life:20}));
        } else {
            let type='basic', speed=12, grav=false;
            if(this.data.weapon==='bomb') { type='proj_bomb'; speed=8; grav=true; }
            projectiles.push(new Projectile(this.id, this.x+dir*20, this.y-30, dir*speed, grav?-5:0, {type, damage:3, color:this.color, gravity:grav}));
        }
    }
    
    applyStatus(type, duration) {
        if (type === 'shatter') {
             const existing = this.buffs.find(b => b.type === 'shatter');
             if (existing && existing.stacks < 2) existing.stacks++;
             else if (!existing) this.buffs.push({type: 'shatter', timer: duration, stacks: 1});
             floatingTexts.push(new FloatingText(this.x, this.y-50, "SHATTERED", "gray"));
             return;
        }
        if (!this.buffs.find(b => b.type === type)) {
            this.buffs.push({type, timer: duration});
            let text = type;
            if(type==='poison') text="POISONED";
            if(type==='weak') text="WEAKENED";
            if(type==='bleed') text="BLEEDING";
            if(type==='burn') text="BURNING";
            if(type==='slow_short') text="SLOWED";
            if(type==='grounded') text="GROUNDED";
            if(type==='defense_up') text="DEFENSE UP";
            if(type==='vulnerable') text="EXPOSED";
            if(type==='fate_link') text="FATE LINKED";
            floatingTexts.push(new FloatingText(this.x, this.y-50, text, 'white'));
        }
    }

    spawnRemnant() { effects.push(new Remnant(this.id, this.x, this.y, this.facingRight)); }
    dodge() { 
        if(this.cooldowns[3]>0 || (this.buffs.find(b=>b.type==='grounded'))) return; 
        this.vx = (this.facingRight?1:-1)*15; this.cooldowns[3]=60; this.invincible=20; updateCd(this.id, 'dodge', 60); 
    }
    
    takeDamage(n, sourcePlayer, type='hit') {
        if(this.invincible>0 || globalRule === 'silence') return; 
        
        // Defense check
        if (this.buffs.find(b => b.type === 'defense_up')) n *= (this.data.id === 'lingxiao' ? 0.7 : 0.5);
        if (this.buffs.find(b => b.type === 'vulnerable')) n *= 1.3;
        const shat = this.buffs.find(b => b.type === 'shatter');
        if (shat) n *= (1 + shat.stacks * 0.2); 

        if (sourcePlayer && sourcePlayer.buffs.find(b => b.type === 'weak')) n *= 0.7;
        if (sourcePlayer && sourcePlayer.data.id === 'lingxiao') n *= (1 + sourcePlayer.xiangangStacks * 0.02);

        if (this.data.id === 'ember' && this.energy > 75) n *= 1.3;

        if (this.data.id === 'ohm' && this.isAbsorbing && n > 0) {
            if(this.ohmStorage < 3) { 
                this.ohmStorage++; 
                createExplosion(this.x, this.y-30, '#00ffff', 10); 
                floatingTexts.push(new FloatingText(this.x, this.y-50, "âš¡ CHARGE!", "#00ffff"));
            } 
            return;
        }

        if (this.data.id === 'khaos' && this.causalLink > 0 && sourcePlayer) { 
            sourcePlayer.takeDamage(n, null, 'reflect'); 
            createExplosion(this.x, this.y-30, 'red', 5); 
            floatingTexts.push(new FloatingText(this.x, this.y-60, "REFLECT!", "red"));
            return; 
        }
        
        if (sourcePlayer && sourcePlayer.data.id === 'khaos' && sourcePlayer.causalLink > 0) sourcePlayer.heal(n);
        if (globalRule === 'fragile') { n *= 2; floatingTexts.push(new FloatingText(this.x, this.y-40, "CRIT!", "orange")); }
        
        if (type !== 'swap') {
            const paradox = effects.find(e => e instanceof Trap && e.type === 'khaos_field');
            if (paradox && paradox.subType === 'effect' && Math.abs(this.x - paradox.x) < 150) { 
                this.heal(n, 'swap'); 
                return; 
            }
        }

        if(this.buffs.find(b=>b.type==='counter') && sourcePlayer) { sourcePlayer.takeDamage(n, this, 'reflect'); this.buffs=[]; return; }

        if (type !== 'shared' && this.buffs.find(b => b.type === 'fate_link')) {
             const other = players.find(p => p.id !== this.id);
             if (other) other.takeDamage(n, sourcePlayer, 'shared');
        }

        this.hp -= n; 
        if (sourcePlayer) sourcePlayer.addCombo();
        
        const hpText = this.data.id === 'samsara' ? "LOAD: " : "HP: ";
        floatingTexts.push(new FloatingText(this.x, this.y-30, "-" + Math.floor(n) + " | " + hpText + Math.floor(this.hp), "red"));

        if(this.hp<=0) endGame(this.id==='p1'?'P2':'P1'); 
        updateHp(); createExplosion(this.x,this.y-30,'red',5);
    }

    heal(n, type='normal') { 
        if(globalRule === 'silence') return;
        if (type !== 'swap') {
            const paradox = effects.find(e => e instanceof Trap && e.type === 'khaos_field');
            if (paradox && paradox.subType === 'effect' && Math.abs(this.x - paradox.x) < 150) { this.takeDamage(n, null, 'swap'); return; }
        }
        
        if (this.data.id === 'samsara' && this.buffs.find(b => b.type === 'fate_link') && this.hp + n >= 90) {
             const enemy = players.find(p => p.id !== this.id);
             if (enemy) {
                 enemy.takeDamage(30, this);
                 createExplosion(enemy.x, enemy.y, 'white', 50);
                 floatingTexts.push(new FloatingText(enemy.x, enemy.y-60, "FATE OVERLOAD!", "white"));
             }
        }

        this.hp = Math.min(this.hp+n, this.maxHp); 
        updateHp(); 
        createExplosion(this.x,this.y-30,'lime',5);
        const hpText = this.data.id === 'samsara' ? "LOAD: " : "HP: ";
        floatingTexts.push(new FloatingText(this.x, this.y-30, "+" + Math.floor(n) + " | " + hpText + Math.floor(this.hp), "lime"));
    }
    
    stun(t) { this.stunTimer = t; floatingTexts.push(new FloatingText(this.x, this.y-50, "STUNNED", "yellow")); }

    useSkill(idx) {
        if(this.cooldowns[idx]>0 || this.stunTimer>0 || this.isAbsorbing) return;
        if(globalRule === 'silence' && idx !== 3) return; 
        
        // Ember Block
        if (this.data.id === 'ember') {
            if (this.exhaustionTimer > 0) return; 
            if (idx === 0 && this.energy < 20 && !this.emberPulseActive) return;
            if (idx === 2 && this.energy < 30) return;
        }

        // Ling Xiao Resource Check
        if (this.data.id === 'lingxiao') {
            if (this.danyuan <= 0) return;
            this.danyuan--;
            const slot = this.danyuanTimers.findIndex(t => t <= 0);
            if (slot !== -1) this.danyuanTimers[slot] = 180; 
            else this.danyuanTimers[2] = 180; 
            this.lingRecentUsage.push(Date.now());
            this.lingRecentUsage = this.lingRecentUsage.filter(t => Date.now() - t < 3000);
            if (this.lingRecentUsage.length >= 2) { 
                this.stasisTimer = 120; floatingTexts.push(new FloatingText(this.x, this.y-60, "STASIS", "gray"));
            }
        }

        const s = this.data.skills[idx];
        this.cooldowns[idx] = s.cd; updateCd(this.id, idx, s.cd);
        const enemy = players.find(p=>p.id!==this.id);
        if(enemy) this.facingRight = enemy.x > this.x; 
        const dir = this.facingRight ? 1 : -1;

        // --- UNIFIED SKILL SWITCH (Fixing Logic Holes) ---
        switch(s.type) {
            // Generic / Old Characters
            case 'dash_dmg':
                this.vx = dir * 25; 
                this.invincible = 15; 
                setTimeout(() => { if(enemy && getDist(this.x, this.y, enemy.x, enemy.y) < 100) enemy.takeDamage(s.damage, this); }, 100);
                break;
            case 'aoe_self':
                createExplosion(this.x, this.y-30, this.color, 20);
                if (enemy && getDist(this.x, this.y, enemy.x, enemy.y) < s.radius) {
                    enemy.takeDamage(s.damage, this);
                    if(this.data.id==='blade') enemy.applyStatus('vulnerable', 240);
                }
                break;
            case 'buff':
                this.buffs.push({type: s.buffType, timer: s.duration});
                floatingTexts.push(new FloatingText(this.x, this.y-60, "COUNTER", "white"));
                break;
            case 'proj_multi':
                [-2, -1, 0, 1, 2].forEach(d => projectiles.push(new Projectile(this.id, this.x, this.y-30, dir*10, d, {damage:s.damage, color:this.color})));
                break;
            case 'trap':
                const t = new Trap(this.id, this.x, GROUND_Y, s.damage, s.duration, 'trap');
                if(this.data.id==='archer') t.applyBleed = true;
                effects.push(t);
                break;
            case 'evade_shot':
                this.vx = -dir * 15; this.vy = -8;
                projectiles.push(new Projectile(this.id, this.x, this.y-30, dir*15, 0, {damage:s.damage, color:this.color}));
                break;
            case 'proj_heavy':
                projectiles.push(new Projectile(this.id, this.x, this.y-40, dir*10, -8, {type:'proj_heavy', damage:s.damage, color:this.color, gravity:true}));
                break;
            case 'heal':
                this.heal(s.amount);
                if (this.data.id === 'paladin') this.applyStatus('defense_up', 180);
                break;
            case 'aoe_ground':
                if (enemy) {
                    effects.push(new Trap(this.id, enemy.x, GROUND_Y, s.damage, 10, 'instant'));
                    if (this.data.id === 'paladin') enemy.applyStatus('weak', 300);
                } else {
                    effects.push(new Trap(this.id, this.x + dir * 100, GROUND_Y, s.damage, 10, 'instant'));
                }
                createExplosion(this.x, GROUND_Y, 'gold', 30);
                break;
            case 'proj_bomb':
                projectiles.push(new Projectile(this.id, this.x, this.y-40, dir*10, -8, {type:'proj_bomb', damage:s.damage, color:this.color, gravity:true}));
                break;
            case 'jump_atk':
                this.vy = -18; this.vx = dir * 8;
                setTimeout(()=>effects.push(new Trap(this.id, this.x, GROUND_Y, s.damage, 10, 'instant')), 600);
                break;
            case 'summon_drone':
                effects.push(new Summon(this.id, this.x, this.y-50, 'drone'));
                break;
            case 'proj_homing':
                projectiles.push(new Projectile(this.id, this.x, this.y-40, dir*8, 0, {type:'proj_homing', damage:s.damage, color:this.color}));
                break;
            case 'summon':
                effects.push(new Summon(this.id, this.x+dir*50, this.y-20, 'skeleton'));
                break;
            case 'drain':
                if(enemy && getDist(this.x, this.y, enemy.x, enemy.y) < s.range) {
                    enemy.takeDamage(s.damage, this); this.heal(s.damage);
                    createExplosion(enemy.x, enemy.y, 'purple', 10);
                }
                break;
            case 'proj_fast':
                projectiles.push(new Projectile(this.id, this.x, this.y-30, dir*20, 0, {damage:s.damage, color:this.color}));
                setTimeout(()=>projectiles.push(new Projectile(this.id, this.x, this.y-30, dir*20, 0, {damage:s.damage, color:this.color})), 100); // Double throw
                break;
            case 'clone':
                effects.push(new Summon(this.id, this.x, this.y, 'clone'));
                this.x += dir * 150;
                break;
            case 'teleport_back':
                if (enemy) {
                    this.x = enemy.x - (enemy.facingRight ? 50 : -50);
                    this.y = enemy.y;
                    enemy.takeDamage(s.damage, this);
                    floatingTexts.push(new FloatingText(this.x, this.y-50, "CRIT!", "red"));
                }
                break;

            // Samsara
            case 'samsara_q':
                let dmg = 20; // Buffed base
                if (this.hp > 50) { dmg += (this.hp - 50) * 1.2; this.hp = 50; updateHp(); } 
                projectiles.push(new Projectile(this.id, this.x, this.y-30, dir*15, 0, {type:'proj_homing', damage:dmg, color:'white'}));
                shakeScreen();
                break;
            case 'samsara_w':
                let cleansed = this.buffs.length > 0 || this.stunTimer > 0;
                this.buffs = []; this.stunTimer = 0;
                if (enemy) enemy.buffs = []; 
                createExplosion(this.x, this.y, 'cyan', 50);
                if (cleansed) this.heal(25); // Buffed heal
                break;
            case 'samsara_e':
                if (enemy) {
                    this.buffs.push({type: 'fate_link', timer: 300});
                    enemy.buffs.push({type: 'fate_link', timer: 300});
                    floatingTexts.push(new FloatingText(this.x, this.y-60, "FATE LINKED", "white"));
                }
                break;

            // Ling Xiao
            case 'ling_q':
                setTimeout(() => { effects.push(new Trap(this.id, enemy ? enemy.x : this.x + dir*150, GROUND_Y, 15, 10, 'ling_star')); }, 400); 
                break;
            case 'ling_w':
                this.buffs.push({type: 'defense_up', timer: 240});
                this.buffs.push({type: 'ling_regen', timer: 240});
                break;
            case 'ling_e':
                projectiles.push(new Projectile(this.id, this.x, this.y-40, dir*12, 0, {type:'ling_bind', damage:5, color:'#e6e6fa'}));
                break;

            // Ember
            case 'ember_pulse':
                const pulse = projectiles.find(p => p.oid === this.id && p.cfg.isPulse);
                if (pulse) {
                    pulse.marked = true; createExplosion(pulse.x, pulse.y, 'orange', 50);
                    if (enemy && getDist(pulse.x, pulse.y, enemy.x, enemy.y) < 120) {
                        let edmg = 20; if (this.energy > 75) edmg *= 2; 
                        enemy.takeDamage(edmg, this); enemy.stun(30);
                    }
                    this.emberPulseActive = false; shakeScreen();
                } else if (this.energy >= 20) {
                    this.energy -= 20;
                    projectiles.push(new Projectile(this.id, this.x, this.y-30, dir*8, 0, {type:'ember_pulse', damage:10, color:'orange', isPulse:true}));
                    this.emberPulseActive = true;
                    // No CD set yet, wait for detonation
                    this.cooldowns[idx] = 0; updateCd(this.id, idx, 0);
                }
                break;
            case 'ember_overload_buff':
                this.buffs.push({type: 'overload', timer: 240});
                effects.push(new ChaosDice(this, Math.floor(this.energy), "SHIELD"));
                setTimeout(() => { this.exhaustionTimer = 240; floatingTexts.push(new FloatingText(this.x, this.y-60, "EXHAUSTED", "gray")); }, 4000);
                break;
            case 'ember_singularity':
                this.energy -= 30;
                effects.push(new Summon(this.id, this.x + dir * 200, this.y-50, 'singularity'));
                break;

            // Khaos
            case 'khaos_link':
                this.causalLink = 300; 
                floatingTexts.push(new FloatingText(this.x, this.y-80, "LINKED!", "red"));
                break;
            case 'khaos_field':
                effects.push(new Trap(this.id, this.x, GROUND_Y, 0, 240, 'khaos_field', 'cause')); // Simplified to random or fixed for now since ring logic was complex
                break;
            case 'khaos_ult':
                startGlobalRule('chaos', 360); shakeScreen();
                break;

            // Ohm
            case 'ohm_absorb':
                this.isAbsorbing = true; floatingTexts.push(new FloatingText(this.x, this.y-60, "SHIELD", "#00ffff")); setTimeout(()=>this.isAbsorbing=false, 1500);
                break;
            case 'ohm_release':
                let odmg = 10 + (this.ohmStorage * 15);
                projectiles.push(new Projectile(this.id, this.x, this.y-40, dir*12, 0, {type:'proj_homing', damage:odmg, color:'#00ffff'}));
                if(this.ohmStorage>0) this.ohmStorage--;
                break;
            case 'ohm_overload':
                createExplosion(this.x, this.y, '#00ffff', 80); shakeScreen();
                if (enemy && getDist(this.x, this.y, enemy.x, enemy.y)<250) {
                    let odmg = this.ohmStorage * 30; if(this.ohmStorage === 3) odmg = enemy.hp * 0.5;
                    enemy.takeDamage(Math.max(20, odmg), this); enemy.stun(40);
                }
                this.ohmStorage = 0;
                break;

            // Knox
            case 'chaos_missile':
                 projectiles.push(new Projectile(this.id, this.x, this.y-40, dir*8, 0, {type:'chaos_missile', damage:15, color:this.color}));
                 break;
            case 'chaos_shift':
                 if (enemy && getDist(this.x, this.y, enemy.x, enemy.y) < 150) {
                     const tx=this.x; this.x=enemy.x; enemy.x=tx; createExplosion(this.x, this.y, '#00ffaa');
                 }
                 break;
            case 'chaos_summon':
                const types=['slime','imp','chest','lightning'];
                effects.push(new Summon(this.id, this.x+dir*60, this.y-50, types[Math.floor(Math.random()*types.length)]));
                break;

            // Sera
            case 'void_swap':
                 this.spawnRemnant(); this.vx=-dir*20;
                 break;
            case 'void_beam':
                 effects.push(new Beam(this.id, this.x+dir*20, this.y-30, dir, 25, 20));
                 break;
            case 'void_echo':
                 effects.filter(e=>e instanceof Remnant).forEach(r=>r.mimic('void_beam'));
                 break;
        }
    }
}

// --- Projectiles & Effects ---
class Projectile extends GameObject {
    constructor(oid,x,y,vx,vy,cfg){super(x,y,cfg.color);this.oid=oid;this.vx=vx;this.vy=vy;this.cfg=cfg;this.timer=0;}
    update() {
        this.timer++; this.x+=this.vx; this.y+=this.vy;
        if(this.cfg.life && this.timer > this.cfg.life) this.marked = true; 
        if(this.cfg.gravity) this.vy += 0.5;
        if(this.cfg.type==='chaos_missile' && Math.random()>0.8) this.vy = (Math.random()-0.5)*5;
        if(this.cfg.type==='proj_homing'){ const t=players.find(p=>p.id!==this.oid); if(t){ this.vx+=(t.x>this.x?0.5:-0.5); this.vy+=(t.y-40>this.y?0.5:-0.5); } }
        
        if(this.y>GROUND_Y || this.x<-100 || this.x>canvas.width+100) this.marked=true;
        
        if (this.cfg.type==='ling_bind' && this.y>=GROUND_Y) {
            this.marked=true; effects.push(new Trap(this.oid, this.x, GROUND_Y, 0, 150, 'ling_bind')); createExplosion(this.x, this.y, '#e6e6fa'); return;
        }

        const t = players.find(p=>p.id!==this.oid);
        if(!this.marked && t && Math.abs(t.x-this.x)<20 && Math.abs(t.y-30-this.y)<30) { 
            t.takeDamage(this.cfg.damage, players.find(p=>p.id===this.oid)); 
            this.marked=true; 
            if(this.cfg.type==='proj_bomb' && t) t.applyStatus('burn', 180);
            if(this.oid==='assassin' && this.cfg.damage===8) t.applyStatus('slow_short', 120); 
        }
    }
    draw(ctx) { 
        ctx.fillStyle=this.color; 
        if (this.cfg.type === 'sword_wave') {
            ctx.save(); ctx.translate(this.x, this.y); ctx.rotate(Math.atan2(this.vy, this.vx)); ctx.beginPath(); ctx.moveTo(-10, -20); ctx.quadraticCurveTo(10, 0, -10, 20); ctx.strokeStyle = this.color; ctx.lineWidth=3; ctx.stroke(); ctx.restore();
        } else { ctx.beginPath(); ctx.arc(this.x,this.y,6,0,7); ctx.fill(); }
    }
}

class Trap extends GameObject {
    constructor(oid,x,y,dmg,dur,type='trap', subType=''){super(x,y,type==='khaos_field'?'rgba(200,0,255,0.2)':'#9f3');this.oid=oid;this.dmg=dmg;this.life=dur;this.type=type;this.subType=subType; this.applyBleed=false;}
    update() {
        this.life--; if(this.life<=0) this.marked=true;
        if(this.type==='khaos_field') return; 
        if(this.type==='ling_star' && this.life===5) { 
             createExplosion(this.x, this.y, '#e6e6fa', 30);
             const t = players.find(p=>p.id!==this.oid);
             if(t && Math.abs(t.x-this.x)<60) { t.takeDamage(this.dmg, players.find(p=>p.id===this.oid)); t.applyStatus('shatter', 240); }
        }
        const t = players.find(p=>p.id!==this.oid);
        if(t && Math.abs(t.x-this.x)<25 && t.y>=GROUND_Y-5) { 
            if (this.type==='trap' || this.type==='instant') {
                t.takeDamage(this.dmg, players.find(p=>p.id===this.oid)); this.marked=true; 
                if(this.type==='trap') t.stun(60); if(this.applyBleed) t.applyStatus('bleed', 300);
            }
            if (this.type==='ling_bind') { t.applyStatus('grounded', 20); t.vx *= 0.5; }
        }
    }
    draw(ctx) { 
        if(this.type==='khaos_field') { ctx.fillStyle=this.color; ctx.fillRect(this.x-150, this.y-200, 300, 200); ctx.strokeStyle='#fff'; ctx.strokeRect(this.x-150, this.y-200, 300, 200); }
        else if (this.type==='ling_star') { ctx.fillStyle = `rgba(230, 230, 250, ${this.life/10})`; ctx.beginPath(); ctx.arc(this.x, this.y, 60, 0, Math.PI*2); ctx.fill(); }
        else if (this.type==='ling_bind') { ctx.fillStyle = `rgba(100, 100, 255, 0.3)`; ctx.fillRect(this.x-30, this.y-10, 60, 10); }
        else { ctx.strokeStyle=this.color; ctx.strokeRect(this.x-10,this.y-5,20,5); }
    }
}

class Summon extends GameObject {
    constructor(oid,x,y,type){super(x,y,'#fff');this.oid=oid;this.type=type;this.life=600;this.vx=0;this.vy=0; 
        if(type==='slime'){ this.vy = -10; this.vx = (Math.random()-0.5)*5; } 
    }
    update() {
        this.life--; if(this.life<=0) this.marked=true;
        const t = players.find(p=>p.id!==this.oid);
        const owner = players.find(p=>p.id===this.oid);
        
        if(this.type==='singularity') {
            if(t) { const dist = getDist(this.x, this.y, t.x, t.y); if(dist < 200 && dist > 10) { t.x += (this.x - t.x) * 0.05; t.y += (this.y - t.y) * 0.05; } }
            if(owner && owner.data.id === 'ember' && owner.energy < 100 && this.life%20===0) owner.energy+=1; 
        }
        else if(this.type==='slime'){ 
            this.vy+=0.5; this.y+=this.vy; 
            if(this.y>=GROUND_Y){ this.y=GROUND_Y; this.vy=-8; this.vx=(t&&t.x>this.x?2:-2); } 
            this.x+=this.vx; 
            if(t&&Math.abs(t.x-this.x)<30&&Math.abs(t.y-this.y)<40){t.takeDamage(5);t.stun(30);this.marked=true;} 
        }
        else if(this.type==='imp' || this.type==='drone'){
            if(t) { this.x += (t.x - this.x) * 0.03; this.y += (t.y - 40 - this.y) * 0.03; }
            if(t && Math.abs(t.x-this.x)<20 && Math.abs(t.y-40-this.y)<20) { t.takeDamage(15); this.marked=true; createExplosion(this.x,this.y,'red'); }
        }
        else if(this.type==='lightning' && this.life%60===0) {
             const sx = Math.random() * canvas.width; effects.push(new Beam(this.oid, sx, GROUND_Y - 300, 1, 10, 15, true)); if(t && Math.abs(t.x-sx)<40) t.takeDamage(10);
        }
        else if(this.type==='chest') {
             if(t && Math.abs(t.x-this.x)<30 && Math.abs(t.y-this.y)<30) { this.marked=true; if(Math.random()>0.5) { t.heal(20); } else { t.takeDamage(20); } createExplosion(this.x, this.y, 'gold'); }
        }
        else if(this.type==='skeleton') {
             this.vy+=0.5; this.y+=this.vy; if(this.y>=GROUND_Y) { this.y=GROUND_Y; this.vy=0; this.vx=(t&&t.x>this.x?1:-1); } this.x+=this.vx; if(t&&Math.abs(t.x-this.x)<30) { t.takeDamage(2); this.marked=true; }
        }
    }
    draw(ctx) { 
        ctx.fillStyle = this.type==='singularity'?'black':(this.type==='slime'?'green':(this.type==='imp'?'red':(this.type==='chest'?'brown':'yellow')));
        if(this.type==='skeleton') ctx.fillStyle='white';
        ctx.beginPath(); ctx.arc(this.x,this.y,10,0,7); ctx.fill(); 
        if(this.type==='singularity') { ctx.strokeStyle='purple'; ctx.stroke(); }
        ctx.fillStyle='white'; ctx.font='10px Arial'; ctx.fillText(this.type, this.x-10, this.y-15);
    }
}

class Remnant extends GameObject { constructor(o,x,y,f){super(x,y,'#bd00ff');this.oid=o;this.f=f;this.life=180;} update(){this.life--;if(this.life<=0)this.marked=true;} draw(ctx){ctx.globalAlpha=0.3;ctx.fillStyle=this.color;ctx.fillRect(this.x-5,this.y-50,10,50);ctx.globalAlpha=1;} mimic(t){ if(t==='void_beam') effects.push(new Beam(this.oid, this.x, this.y-30, this.f?1:-1, 10, 10, true)); } }
class Beam extends GameObject { constructor(o,x,y,d,dmg,dur){super(x,y,'#bd00ff');this.oid=o;this.d=d;this.dmg=dmg;this.life=dur;this.hit=false;} update(){this.life--;if(this.life<=0)this.marked=true; if(!this.hit){const t=players.find(p=>p.id!==this.oid); if(t){const min=this.d>0?this.x:this.x-1000; const max=this.d>0?this.x+1000:this.x; if(t.x>min && t.x<max && Math.abs(t.y-30-this.y)<40){t.takeDamage(this.dmg, players.find(p=>p.id===this.oid));this.hit=true;}}}} draw(ctx){ctx.fillStyle=this.color;ctx.fillRect(this.d>0?this.x:this.x-1000,this.y-5,1000,10);} }
class ChaosDice extends GameObject { constructor(o,v,t){super(o.x,o.y-80,'#fff');this.v=v;this.t=t;this.life=100;this.vy=-1;} update(){this.life--;this.y+=this.vy;if(this.life<=0)this.marked=true;} draw(ctx){ctx.fillStyle='#fff';ctx.fillText(this.v,this.x,this.y);ctx.font='10px Arial';ctx.fillText(this.t,this.x,this.y-15);} }
class SpeechBubble extends GameObject { constructor(o,t){super(o.x,o.y-100,'#fff');this.o=o;this.t=t;this.life=150;} update(){this.life--;if(this.o){this.x=this.o.x;this.y=this.o.y-90;}if(this.life<=0)this.marked=true;} draw(ctx){ctx.fillStyle='#fff';ctx.fillRect(this.x-40,this.y-15,80,30);ctx.fillStyle='#000';ctx.font='12px Arial';ctx.textAlign='center';ctx.fillText(this.t,this.x,this.y+5);} }

function createExplosion(x,y,c,n=5) { for(let i=0;i<n;i++) effects.push(new Particle(x,y,c,(Math.random()-0.5)*5,(Math.random()-0.5)*5,Math.random()*3,15)); }
function getDist(x1,y1,x2,y2){ return Math.sqrt(Math.pow(x2-x1,2)+Math.pow(y2-y1,2)); }
function shakeScreen() { shakeTimer = 15; }

// --- Global Rules ---
function startGlobalRule(rule, duration) {
    globalRule = rule; globalRuleTimer = duration; createExplosion(canvas.width/2, canvas.height/2, 'white', 50);
    if(rule === 'chaos') shuffleButtons();
    let msg = ""; if(rule==='silence')msg="â›” SILENCE!"; if(rule==='fragile')msg="ğŸ’” FRAGILE!"; if(rule==='chaos')msg="ğŸŒ€ CHAOS!";
    floatingTexts.push(new FloatingText(canvas.width/2, canvas.height/2, msg, "white", 120));
}
function updateGlobalRules() { if(globalRuleTimer > 0) { globalRuleTimer--; if(globalRuleTimer <= 0) { globalRule = null; resetButtons(); } } }
function shuffleButtons() { document.querySelectorAll('.controls-layer .touch-btn').forEach(btn => { btn.style.top = Math.random() * 80 + '%'; btn.style.left = Math.random() * 80 + '%'; }); }
function resetButtons() { document.querySelectorAll('.controls-layer .touch-btn').forEach(btn => { btn.style.top=''; btn.style.left=''; btn.style.bottom=''; }); }

// --- UI / Main ---
function setupTouchListeners() {
    document.querySelectorAll('.touch-btn').forEach(btn => {
        btn.addEventListener('touchstart', e => {
            if(btn.classList.contains('p1-chat') || btn.classList.contains('p2-chat')) return;
            e.preventDefault(); const key = btn.dataset.key; if(!key) return; const [pid, act] = key.split('-');
            if(isPvE && pid==='p2') return;
            inputState[pid] = inputState[pid] || {}; inputState[pid][act] = true; btn.classList.add('active');
            if(act.startsWith('s') || act==='dodge' || act==='atk') handleAction(pid, act);
        }, {passive:false});
        btn.addEventListener('touchend', e => {
            if(btn.classList.contains('p1-chat') || btn.classList.contains('p2-chat')) return;
            e.preventDefault(); const key = btn.dataset.key; if(!key) return; const [pid, act] = key.split('-');
            if(isPvE && pid==='p2') return;
            if(inputState[pid]) inputState[pid][act] = false; btn.classList.remove('active');
        }, {passive:false});
    });
}
function handleAction(pid, act) {
    if (gameState !== 'FIGHT') return;
    const p = players.find(pl => pl.id === pid);
    if (!p) return;
    if (act === 'dodge') p.dodge(); else if (act === 'atk') p.basicAttack(); else if (act.startsWith('s')) p.useSkill(parseInt(act.charAt(1)));
}

function toggleMode() { isPvE = !isPvE; document.getElementById('mode-toggle').innerText = isPvE ? "æ¨¡å¼ï¼šäººæ©Ÿå°æˆ° (AI)" : "æ¨¡å¼ï¼šé›™äººå°æˆ°"; }
function initCharSelect() {
    const g = document.getElementById('char-grid'); g.innerHTML='';
    CHARACTERS.forEach((c,i)=>{
        const d=document.createElement('div'); d.className='char-card'; 
        if(c.id==='samsara' || c.id==='lingxiao' || c.id==='ember' || c.id==='khaos' || c.id==='ohm' || c.id==='knox') d.innerHTML+='<span class="new-tag">NEW</span>';
        d.innerHTML+=`<div class="char-icon" style="color:${c.color}">${c.icon}</div><div class="char-name">${c.name}</div>`;
        d.onclick=()=>showCharInfo(i); d.id=`c-${i}`; g.appendChild(d);
    });
}
function showCharInfo(i) {
    document.querySelectorAll('.char-card').forEach(c=>c.classList.remove('selected'));
    document.getElementById(`c-${i}`).classList.add('selected');
    const c = CHARACTERS[i];
    document.getElementById('info-placeholder').style.display = 'none';
    document.getElementById('info-panel').style.display = 'block';
    document.getElementById('info-name').innerText = c.name;
    document.getElementById('info-name').style.color = c.color;
    document.getElementById('info-role').innerText = "ç”Ÿå‘½: " + c.hp + " | é€Ÿåº¦: " + c.speed;
    document.getElementById('info-desc').innerText = c.desc;
    let html = ''; c.skills.forEach(s => html += `<div class="skill-info"><div class="skill-name">${s.name}</div><div class="skill-detail">${s.desc}</div></div>`);
    document.getElementById('info-skills').innerHTML = html;
    const btn = document.getElementById('confirm-btn'); btn.disabled = false; btn.onclick = () => confirmSelection(i); btn.innerText = `é–å®š ${turn}`;
}
function confirmSelection(i) {
    if (turn === 'P1') {
        p1CharIndex = i; turn = 'P2'; document.getElementById('select-title').innerText = "P2 (ç´…è‰²) è«‹é¸æ“‡"; document.getElementById('select-title').style.color = '#f44'; document.getElementById('confirm-btn').disabled = true;
        if (isPvE) { p2CharIndex = Math.floor(Math.random() * CHARACTERS.length); startGame(); }
    } else { p2CharIndex = i; startGame(); }
}
function startGame() {
    gameState='FIGHT'; document.getElementById('char-select-screen').style.display='none';
    document.getElementById('p1-controls').style.display='block'; if(!isPvE) document.getElementById('p2-controls').style.display='block';
    players = [new Player('p1',100,CHARACTERS[p1CharIndex]), new Player('p2',canvas.width-100,CHARACTERS[p2CharIndex])];
    if(isPvE) players[1].inputAI = {}; 
    document.getElementById('p1-name').innerText=players[0].data.name; document.getElementById('p2-name').innerText=players[1].data.name;
    ['p1','p2'].forEach((pid,i)=>{ for(let j=0;j<3;j++) { const el=document.querySelector(`.${pid}-s${j+1} .skill-label`); if(el) el.innerText=players[i].data.skills[j].name.substring(0,2); } });
    updateHp(); gameLoop();
}
function updateHp() { if(players.length<2)return; document.getElementById('p1-hp').style.width=(players[0].hp/players[0].maxHp*100)+'%'; document.getElementById('p2-hp').style.width=(players[1].hp/players[1].maxHp*100)+'%'; }
function updateCd(pid,i,max) {
    const el = document.querySelector(`.${pid}-${i==='dodge'?'dodge':'s'+(i+1)} .cd-overlay`);
    if(!el) return; el.style.display='flex'; let f=max;
    const t = setInterval(()=>{ f-=5; el.innerText=Math.ceil(f/60); if(f<=0){clearInterval(t);el.style.display='none';} }, 80);
    activeTimers.push(t);
}
function endGame(w) { gameState='END'; document.getElementById('game-over-msg').style.display='block'; document.getElementById('winner-text').innerText=w+" ç²å‹!"; }
function resetGame() {
    gameState='SELECT'; p1CharIndex=-1; p2CharIndex=-1; turn='P1'; players=[]; projectiles=[]; effects=[]; floatingTexts=[]; inputState={p1:{},p2:{}};
    globalRule=null; globalRuleTimer=0;
    if(gameLoopId) cancelAnimationFrame(gameLoopId); gameLoopId = null; 
    
    document.getElementById('game-over-msg').style.display='none'; document.getElementById('p1-controls').style.display='none'; document.getElementById('p2-controls').style.display='none';
    document.getElementById('char-select-screen').style.display='flex'; document.getElementById('select-title').innerText="P1 (è—è‰²) é¸æ“‡"; document.getElementById('select-title').style.color='#0af';
    document.getElementById('info-panel').style.display='none'; document.getElementById('info-placeholder').style.display='block';
    
    document.getElementById('p1-ling-bar').style.display='none'; document.getElementById('p2-ling-bar').style.display='none';
    document.getElementById('p1-ember-bar').style.display='none'; document.getElementById('p2-ember-bar').style.display='none';

    activeTimers.forEach(clearInterval); activeTimers=[];
    initCharSelect();
}

function gameLoop() {
    if(gameState==='FIGHT') {
        ctx.save();
        if (shakeTimer > 0) {
            shakeTimer--;
            const dx = (Math.random() - 0.5) * 10;
            const dy = (Math.random() - 0.5) * 10;
            ctx.translate(dx, dy);
        }
        
        ctx.fillStyle='#111'; ctx.fillRect(0,0,canvas.width,canvas.height);
        if (globalRule === 'chaos') { ctx.fillStyle = 'rgba(50,0,50,0.2)'; ctx.fillRect(0,0,canvas.width,canvas.height); }
        else if (globalRule === 'silence') { ctx.fillStyle = 'rgba(0,0,0,0.5)'; ctx.fillRect(0,0,canvas.width,canvas.height); }
        ctx.fillStyle='#333'; ctx.fillRect(0,GROUND_Y,canvas.width,canvas.height-GROUND_Y);
        updateGlobalRules();
        [...players,...projectiles,...effects, ...floatingTexts].forEach(o=>o.update());
        projectiles=projectiles.filter(p=>!p.marked); effects=effects.filter(e=>!e.marked); floatingTexts=floatingTexts.filter(t=>t.life>0);
        [...effects,...players,...projectiles, ...floatingTexts].forEach(o=>o.draw(ctx));
        
        ctx.restore();
    }
    gameLoopId = requestAnimationFrame(gameLoop);
}

// AI & Status Guide
function showStatusGuide() { showAiModal(STATUS_INFO); }
function showAiModal(t) { document.getElementById('ai-modal').style.display='block'; document.getElementById('ai-content').innerHTML=t; }
async function askAiForTips() {
    if(p1CharIndex===-1 && turn==='P1') { showAiModal("è«‹å…ˆé»æ“Šé¸æ“‡ä¸€å€‹è§’è‰²ã€‚"); return; }
    const c = CHARACTERS[turn==='P1'?p1CharIndex:p2CharIndex];
    if(!c) { showAiModal("è«‹å…ˆé»æ“Šé¸æ“‡ä¸€å€‹è§’è‰²ã€‚"); return; }
    showAiModal("AI åˆ†æä¸­...");
    const res = await callGemini(`æ ¼é¬¥éŠæˆ²å»ºè­°ï¼šè§’è‰²${c.name}ï¼ŒæŠ€èƒ½${c.skills.map(s=>s.name)}ã€‚è«‹çµ¦3å€‹çŸ­å»ºè­°(ç¹é«”ä¸­æ–‡)ã€‚`);
    document.getElementById('ai-content').innerText = res;
}
async function generateBattleReport() {
    showAiModal("AI æ’°å¯«æˆ°å ±ä¸­...");
    const w = players[0].hp>0?players[0]:players[1]; const l = players[0].hp>0?players[1]:players[0];
    const res = await callGemini(`è³½å¾Œè¬›è©•ï¼šè´å®¶${w.data.name}ï¼Œè¼¸å®¶${l.data.name}ã€‚è«‹ç”¨æ¿€å‹•èªæ°£è©•è«–(80å­—å…§ç¹é«”ä¸­æ–‡)ã€‚`);
    document.getElementById('ai-content').innerText = res;
}
async function triggerTaunt(pid) {
    const p = players.find(pl=>pl.id===pid); if(!p) return;
    effects.push(new SpeechBubble(p, "..."));
    const res = await callGemini(`è§’è‰²${p.data.name}çš„å˜²è«·å°è©(10å­—å…§ç¹é«”ä¸­æ–‡ï¼Œä¸è¦å¼•è™Ÿ)ã€‚`);
    effects = effects.filter(e=>!(e instanceof SpeechBubble && e.o===p));
    effects.push(new SpeechBubble(p, res));
}

setupTouchListeners();
initCharSelect();
</script>
</body>
</html>
